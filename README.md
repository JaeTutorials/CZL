# CZL 概述
* 纯C写成的极简语法风格脚本语言；
* 高效的寄存器模型解释执行架构；
* 动静态类型混合编程，不存在空类型；
* 支持完备的面向对象编程和对象引用；
* 内置多线程、定时器和网络并发模块；
* MVM 架构，每个线程独立维护一个VM；
* 具备良好工程管理框架和热更新技术；
* 提供全自动实时资源管理方案，原创；
* 跨Windows和Linux平台，其他平台暂时不支持多线程等系统资源模块。

# CZL 特色
* 虚拟进程，CZL内部通过系统线程模拟用户进程，用户可轻松编写无锁多核程序；
* 实时回收、实时碎片整理的内存管理模型，用户无需再担心垃圾回收的任何问题；
* 良好的第三方资源扩展框架，凡是通过CZL扩展框架接管的资源均可实时回收整理。

# CZL 内存模型
分四层：
1. 系统交互层: czl_malloc/czl_free...，其中采用了内存池、范围分级和映射技术；
2. 语言接口层: CZL_STR_MALLOC/CZL_STR_FREE、CZL_STACK_MALLOC/CZL_STACK_CALLOC...，不同模块采用不同接口；
3. 对象管理层: 引用计数和引用标记；
4. 临时内存管理: 回收时机精确到指令级别。

四层模型让CZL做到了：
1. O(1)时间复杂度内完成czl_malloc/czl_free；
2. 内存池碎片实时整理；
3. 对象生命周期确定，不存在循环引用，所以不存在集中回收过程；
4. 在保证以上三点的情况下，CZL完备地支持了对象引用的所有常规操作。

# CZL 是否吹牛
如果你觉得作者吹牛或民科，请下载解释器执行如下代码：
```c
class student
{
	int id
	int age
	str name
	float grade
}

main
{
	//缓存等级设置为0，即每次删除对象立即回收并整理内存碎片
	setRank(0)
	
	a = {}
	
	//新建一个百万对象哈希表查看内存占用
	for i in (0, 1000000)
		a[i] = new student
	echo(#a, ": ", useMem())
	input() //按下回车继续
	
	//间隔删除五十万个对象后查看内存占用
	for i in (0, 1000000, 2)
		i => a
	echo(#a, ": ", useMem())
	input() //按下回车退出
	
	//对比系统监控内存变化可知CZL在间隔删除一半对象后系统回收了这些内存
}
```
对循环引用感兴趣的读者可学习CZL语言后跑个图论看看内存是否实时回收并实时整理了，结果很美妙。

# CZL 适用场景
* 灵活热更新；
* 内存常驻或不常驻；
* 高可靠、高实时性；
* CPU、IO混合高并发；
* 黑科技适合学习、参考和二次开发。

# CZL 发展方向
* 为物联网应用提供高可靠、高实时性方案，跟进5G-IOT发展；
* 构建物联网应用基础生态，集成优秀的开源跨平台库；
* 为第三方平台提供定制版热更新技术。

# CZL 愿景
让程序员感受最纯粹的编程快感，让实现想法的过程不受限于反人类的语法限制，让CZL成为一门具备生产力的编程语言。
